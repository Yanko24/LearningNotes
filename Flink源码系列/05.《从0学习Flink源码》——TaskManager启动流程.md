### ã€Šä»0å­¦ä¹ Flinkæºç ã€‹â€”â€”TaskManagerå¯åŠ¨æµç¨‹

#### 1. å‰è¨€

ä¸Šä¸€ç¯‡æ–‡ç« æˆ‘ä»¬çœ‹äº†JobManagerçš„å¯åŠ¨è¿‡ç¨‹ï¼ŒæŸ¥çœ‹äº†æºç çš„å…·ä½“å®ç°ï¼Œè¿™ç¯‡æ–‡ç« æˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹TaskManageræ˜¯å¦‚ä½•å¯åŠ¨ï¼Œçœ‹çœ‹å†…éƒ¨çš„æºç æ˜¯å¦‚ä½•å®ç°çš„ã€‚

#### 2. å…¥å£ç±»TaskManagerRunner

è¯¥ç±»ä½äº`flink-runtime`æ¨¡å—ä¸‹ï¼Œä½äºåŒ…`taskexecutor`ä¸­ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä¸€æ ·ï¼Œå…ˆçœ‹çœ‹è¿™ä¸ªç±»çš„ç»§æ‰¿ç»“æ„ï¼š

![](images/TaskManagerRunner.png)

ä»ä¸Šå›¾æˆ‘ä»¬å¯ä»¥çœ‹åˆ°`TaskManagerRunner`ä»…ä»…å®ç°äº†`FatalErrorHandler`æ¥å£ï¼Œé‚£æˆ‘ä»¬æ¥ä¸‹æ¥çœ‹çœ‹è¿™ä¸ªç±»çš„mainæ–¹æ³•ï¼Œçœ‹çœ‹mainæ–¹æ³•ä¸­å…·ä½“åšäº†å“ªäº›äº‹æƒ…ï¼Ÿ

```java
public static void main(String[] args) throws Exception {
    // startup checks and logging
    // å‰å‡ è¡Œå’ŒJobManagerçš„å¯åŠ¨ç±»StandaloneSessionClusterEntrypointå¦‚å‡ºä¸€è¾™
    // è®°å½•æœ‰å…³ç¯å¢ƒçš„ä¿¡æ¯ï¼Œå¦‚ä»£ç ä¿®è®¢ã€å½“å‰ç”¨æˆ·ã€Javaç‰ˆæœ¬å’ŒJVMå‚æ•°
    EnvironmentInformation.logEnvironmentInfo(LOG, "TaskManager", args);
    // æ³¨å†Œä¸€äº›å¤„ç†ä¿¡å·å¤„ç†å™¨
    SignalHandler.register(LOG);
    // å®‰è£…å®‰å…¨å…³æœºæŒ‚é’©ã€‚JVMåœ¨è¢«ç»ˆæ­¢å‰è¢«å…è®¸å…³é—­çš„æœ€é•¿æ—¶é—´æ˜¯5ç§’
    JvmShutdownSafeguard.installAsShutdownHook(LOG);

    long maxOpenFileHandles = EnvironmentInformation.getOpenFileHandlesLimit();

    if (maxOpenFileHandles != -1L) {
        LOG.info("Maximum number of open file descriptors is {}.", maxOpenFileHandles);
    } else {
        LOG.info("Cannot determine the maximum number of open file descriptors");
    }

    // å¯åŠ¨taskmanagerè¿›ç¨‹ ğŸ”¥
    runTaskManagerProcessSecurely(args);
}
```

å¯ä»¥çœ‹åˆ°å…¶ä»–çš„å’Œ`JobManager`çš„å…¥å£ç±»å·®ä¸å¤šï¼Œé‡ç‚¹åœ¨`runTaskManagerProcessSecurely`æ–¹æ³•ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç»§ç»­æ·±å…¥çœ‹çœ‹å…¶å…·ä½“å®ç°ã€‚

#### 3. runTaskManagerProcessSecurely

```java
public static void runTaskManagerProcessSecurely(String[] args) {
    Configuration configuration = null;

    try {
        // loadConfigurationåŠ è½½argsï¼Œæœ€åå’ŒJobManagerè§£æç”ŸæˆConfigurationåŸºæœ¬ä¸€è‡´
        configuration = loadConfiguration(args);
    } catch (FlinkParseException fpe) {
        LOG.error("Could not load the configuration.", fpe);
        System.exit(FAILURE_EXIT_CODE);
    }

    // å°†configurationä¼ å…¥è°ƒç”¨runTaskManagerProcessSecurelyå¯åŠ¨taskmanager ğŸ”¥
    runTaskManagerProcessSecurely(checkNotNull(configuration));
}
```

å…³äº`loadConfiguration`çš„å…·ä½“å®ç°å°±ä¸ç»§ç»­æ·±å…¥çœ‹äº†ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥çœ‹çœ‹`runTaskManagerProcessSecurely`çš„å…·ä½“å®ç°ï¼š

```java
public static void runTaskManagerProcessSecurely(Configuration configuration) {
    FlinkSecurityManager.setFromConfiguration(configuration);
    final PluginManager pluginManager =
            PluginUtils.createPluginManagerFromRootFolder(configuration);
    // åˆå§‹åŒ–é…ç½®æ–‡ä»¶å’ŒPluginManagerå…±äº«æ–‡ä»¶è®¾ç½®
    FileSystem.initialize(configuration, pluginManager);

    int exitCode;
    Throwable throwable = null;

    try {
        // å®‰è£…ç›¸å…³çš„å®‰å…¨é…ç½®
        SecurityUtils.install(new SecurityConfiguration(configuration));

        // ä¸»è¦å®ç°runTaskManager ğŸ”¥
        exitCode =
                SecurityUtils.getInstalledContext()
                        .runSecured(() -> runTaskManager(configuration, pluginManager));
    } catch (Throwable t) {
        throwable = ExceptionUtils.stripException(t, UndeclaredThrowableException.class);
        exitCode = FAILURE_EXIT_CODE;
    }

    if (throwable != null) {
        LOG.error("Terminating TaskManagerRunner with exit code {}.", exitCode, throwable);
    } else {
        LOG.info("Terminating TaskManagerRunner with exit code {}.", exitCode);
    }

    System.exit(exitCode);
}
```

å¯ä»¥çœ‹åˆ°è¿™å—å’Œ`JobManager`ä¸­`startCluster`çš„å®ç°æœ‰å¾ˆå¤šçš„ç›¸ä¼¼ä¹‹å¤„ï¼Œå¯¹äº`TaskManager`æœ€é‡è¦çš„è¿˜æ˜¯`runTaskManager`æ–¹æ³•ï¼Œæˆ‘ä»¬ç»§ç»­æ·±å…¥çœ‹çœ‹ã€‚

#### 4. runTaskManager

```java
public static int runTaskManager(Configuration configuration, PluginManager pluginManager)
        throws Exception {
    final TaskManagerRunner taskManagerRunner;

    try {
        // åˆ›å»ºTaskManager 1ï¸âƒ£
        taskManagerRunner =
                new TaskManagerRunner(
                        configuration,
                        pluginManager,
                        TaskManagerRunner::createTaskExecutorService);
        // å¯åŠ¨TaskManager 2ï¸âƒ£
        taskManagerRunner.start();
    } catch (Exception exception) {
        throw new FlinkException("Failed to start the TaskManagerRunner.", exception);
    }

    try {
        return taskManagerRunner.getTerminationFuture().get().getExitCode();
    } catch (Throwable t) {
        throw new FlinkException(
                "Unexpected failure during runtime of TaskManagerRunner.",
                ExceptionUtils.stripExecutionException(t));
    }
}
```

##### 1. TaskManagerRunneræ„é€ æ–¹æ³•

```java
public TaskManagerRunner(
        Configuration configuration,
        PluginManager pluginManager,
        TaskExecutorServiceFactory taskExecutorServiceFactory)
        throws Exception {
    this.configuration = checkNotNull(configuration);

    timeout = AkkaUtils.getTimeoutAsTime(configuration);

    this.executor =
            java.util.concurrent.Executors.newScheduledThreadPool(
                    Hardware.getNumberCPUCores(),
                    new ExecutorThreadFactory("taskmanager-future"));

    // åˆ›å»ºHAæœåŠ¡
    highAvailabilityServices =
            HighAvailabilityServicesUtils.createHighAvailabilityServices(
                    configuration,
                    executor,
                    HighAvailabilityServicesUtils.AddressResolution.NO_ADDRESS_RESOLUTION);

    JMXService.startInstance(configuration.getString(JMXServerOptions.JMX_SERVER_PORT));

    // åˆ›å»ºRPCæœåŠ¡
    rpcService = createRpcService(configuration, highAvailabilityServices);

    // èµ„æºID
    this.resourceId =
            getTaskManagerResourceID(
                    configuration, rpcService.getAddress(), rpcService.getPort());

    // åˆ›å»ºå¿ƒè·³æ£€æŸ¥æœåŠ¡
    HeartbeatServices heartbeatServices = HeartbeatServices.fromConfiguration(configuration);

    // åˆ›å»ºmetricæœåŠ¡
    metricRegistry =
            new MetricRegistryImpl(
                    MetricRegistryConfiguration.fromConfiguration(configuration),
                    ReporterSetup.fromConfiguration(configuration, pluginManager));

    final RpcService metricQueryServiceRpcService =
            MetricUtils.startRemoteMetricsRpcService(configuration, rpcService.getAddress());
    metricRegistry.startQueryService(metricQueryServiceRpcService, resourceId);

    // åˆ›å»ºblobæœåŠ¡
    blobCacheService =
            new BlobCacheService(
                    configuration, highAvailabilityServices.createBlobStore(), null);

    final ExternalResourceInfoProvider externalResourceInfoProvider =
            ExternalResourceUtils.createStaticExternalResourceInfoProviderFromConfig(
                    configuration, pluginManager);

    // æ ¹æ®ä¼ å…¥çš„å‚æ•°è°ƒç”¨å·¥å‚ç±»åˆ›å»ºtaskExecutoræœåŠ¡å¯¹è±¡ ğŸ”¥
    taskExecutorService =
            taskExecutorServiceFactory.createTaskExecutor(
                    this.configuration,
                    this.resourceId,
                    rpcService,
                    highAvailabilityServices,
                    heartbeatServices,
                    metricRegistry,
                    blobCacheService,
                    false,
                    externalResourceInfoProvider,
                    this);

    this.terminationFuture = new CompletableFuture<>();
    this.shutdown = false;
    handleUnexpectedTaskExecutorServiceTermination();

    MemoryLogger.startIfConfigured(
            LOG, configuration, terminationFuture.thenAccept(ignored -> {}));
}
```

è¿™å—çš„ä»£ç å’Œ`JobManager`ä¸­`initializeService`ä»£ç éƒ¨åˆ†ä¹Ÿæœ‰äº›è®¸ç±»ä¼¼ï¼Œéƒ½æ˜¯å»åˆ›å»ºä¸€äº›æœåŠ¡ï¼Œåšå¥½å‡†å¤‡å·¥ä½œã€‚æˆ‘ä»¬å¯ä»¥ç»§ç»­æ·±å…¥çœ‹çœ‹æ˜¯æ€ä¹ˆé€šè¿‡å·¥å‚ç±»åˆ›å»º`taskExecutorService`çš„ã€‚

```java
// TaskManagerRunnerä¸­çš„ä¸€ä¸ªæ¥å£
public interface TaskExecutorServiceFactory {
    TaskExecutorService createTaskExecutor(
            Configuration configuration,
            ResourceID resourceID,
            RpcService rpcService,
            HighAvailabilityServices highAvailabilityServices,
            HeartbeatServices heartbeatServices,
            MetricRegistry metricRegistry,
            BlobCacheService blobCacheService,
            boolean localCommunicationOnly,
            ExternalResourceInfoProvider externalResourceInfoProvider,
            FatalErrorHandler fatalErrorHandler)
            throws Exception;
}

// çœ‹çœ‹æ¥å£çš„å…·ä½“å®ç°å­ç±»çš„æ–¹æ³•â€”â€”TaskManagerRunner::createTaskExecutorService
public static TaskExecutorService createTaskExecutorService(
        Configuration configuration,
        ResourceID resourceID,
        RpcService rpcService,
        HighAvailabilityServices highAvailabilityServices,
        HeartbeatServices heartbeatServices,
        MetricRegistry metricRegistry,
        BlobCacheService blobCacheService,
        boolean localCommunicationOnly,
        ExternalResourceInfoProvider externalResourceInfoProvider,
        FatalErrorHandler fatalErrorHandler)
        throws Exception {

    // è°ƒç”¨startTaskManageråˆ›å»ºTaskExecutorå¯¹è±¡
    final TaskExecutor taskExecutor =
            startTaskManager(
                    configuration,
                    resourceID,
                    rpcService,
                    highAvailabilityServices,
                    heartbeatServices,
                    metricRegistry,
                    blobCacheService,
                    localCommunicationOnly,
                    externalResourceInfoProvider,
                    fatalErrorHandler);

    // å°†taskExecutorä¼ å…¥æ„é€ ä¸€ä¸ªTaskExecutorToServiceAdapterå¯¹è±¡
    return TaskExecutorToServiceAdapter.createFor(taskExecutor);
}
```

`TaskManagerRunner#startTaskManager`çš„æ–¹æ³•ï¼š

```java
// TaskManagerRunner_startTaskManager
public static TaskExecutor startTaskManager(
        Configuration configuration,
        ResourceID resourceID,
        RpcService rpcService,
        HighAvailabilityServices highAvailabilityServices,
        HeartbeatServices heartbeatServices,
        MetricRegistry metricRegistry,
        BlobCacheService blobCacheService,
        boolean localCommunicationOnly,
        ExternalResourceInfoProvider externalResourceInfoProvider,
        FatalErrorHandler fatalErrorHandler)
        throws Exception {

    checkNotNull(configuration);
    checkNotNull(resourceID);
    checkNotNull(rpcService);
    checkNotNull(highAvailabilityServices);

    LOG.info("Starting TaskManager with ResourceID: {}", resourceID.getStringWithMetadata());

    String externalAddress = rpcService.getAddress();

    final TaskExecutorResourceSpec taskExecutorResourceSpec =
            TaskExecutorResourceUtils.resourceSpecFromConfig(configuration);

    // TaskMangeræœåŠ¡çš„ç›¸å…³é…ç½®ï¼ŒåŒ…æ‹¬å†…å­˜ç®¡ç†å™¨ã€IOç®¡ç†å™¨ç­‰
    TaskManagerServicesConfiguration taskManagerServicesConfiguration =
            TaskManagerServicesConfiguration.fromConfiguration(
                    configuration,
                    resourceID,
                    externalAddress,
                    localCommunicationOnly,
                    taskExecutorResourceSpec);

    Tuple2<TaskManagerMetricGroup, MetricGroup> taskManagerMetricGroup =
            MetricUtils.instantiateTaskManagerMetricGroup(
                    metricRegistry,
                    externalAddress,
                    resourceID,
                    taskManagerServicesConfiguration.getSystemResourceMetricsProbingInterval());

    final ExecutorService ioExecutor =
            Executors.newFixedThreadPool(
                    taskManagerServicesConfiguration.getNumIoThreads(),
                    new ExecutorThreadFactory("flink-taskexecutor-io"));

    // TaskExecutoræœåŠ¡çš„å®¹å™¨ï¼Œä¾‹å¦‚MemoryManagerã€IOManagerä»¥åŠShuffleEnvironmentã€‚æ‰€æœ‰æœåŠ¡éƒ½ä¸“å±äºå•ä¸ªTaskExecutorã€‚
    // å› æ­¤ï¼Œç›¸åº”çš„TaskManagerä¹Ÿè´Ÿè´£å…³é—­å®ƒä»¬ã€‚
    TaskManagerServices taskManagerServices =
            TaskManagerServices.fromConfiguration(
                    taskManagerServicesConfiguration,
                    blobCacheService.getPermanentBlobService(),
                    taskManagerMetricGroup.f1,
                    ioExecutor,
                    fatalErrorHandler);

    MetricUtils.instantiateFlinkMemoryMetricGroup(
            taskManagerMetricGroup.f1,
            taskManagerServices.getTaskSlotTable(),
            taskManagerServices::getManagedMemorySize);

    TaskManagerConfiguration taskManagerConfiguration =
            TaskManagerConfiguration.fromConfiguration(
                    configuration, taskExecutorResourceSpec, externalAddress);

    String metricQueryServiceAddress = metricRegistry.getMetricQueryServiceGatewayRpcAddress();

    return new TaskExecutor(
            rpcService,
            taskManagerConfiguration,
            highAvailabilityServices,
            taskManagerServices,
            externalResourceInfoProvider,
            heartbeatServices,
            taskManagerMetricGroup.f0,
            metricQueryServiceAddress,
            blobCacheService,
            fatalErrorHandler,
            new TaskExecutorPartitionTrackerImpl(taskManagerServices.getShuffleEnvironment()));
}
```

```java
// TaskExecutor
public TaskExecutor(
        RpcService rpcService,
        TaskManagerConfiguration taskManagerConfiguration,
        HighAvailabilityServices haServices,
        TaskManagerServices taskExecutorServices,
        ExternalResourceInfoProvider externalResourceInfoProvider,
        HeartbeatServices heartbeatServices,
        TaskManagerMetricGroup taskManagerMetricGroup,
        @Nullable String metricQueryServiceAddress,
        BlobCacheService blobCacheService,
        FatalErrorHandler fatalErrorHandler,
        TaskExecutorPartitionTracker partitionTracker) {

    super(rpcService, AkkaRpcServiceUtils.createRandomName(TASK_MANAGER_NAME));

    checkArgument(
            taskManagerConfiguration.getNumberSlots() > 0,
            "The number of slots has to be larger than 0.");

    this.taskManagerConfiguration = checkNotNull(taskManagerConfiguration);
    this.taskExecutorServices = checkNotNull(taskExecutorServices);
    this.haServices = checkNotNull(haServices);
    this.fatalErrorHandler = checkNotNull(fatalErrorHandler);
    this.partitionTracker = partitionTracker;
    this.taskManagerMetricGroup = checkNotNull(taskManagerMetricGroup);
    this.blobCacheService = checkNotNull(blobCacheService);
    this.metricQueryServiceAddress = metricQueryServiceAddress;
    this.externalResourceInfoProvider = checkNotNull(externalResourceInfoProvider);

    this.libraryCacheManager = taskExecutorServices.getLibraryCacheManager();
    // è·å–slot ğŸ”¥
    this.taskSlotTable = taskExecutorServices.getTaskSlotTable();
    this.jobTable = taskExecutorServices.getJobTable();
    // è·å–JobLeaderæœåŠ¡ ğŸ”¥
    this.jobLeaderService = taskExecutorServices.getJobLeaderService();
    this.unresolvedTaskManagerLocation =
            taskExecutorServices.getUnresolvedTaskManagerLocation();
    // è·å–TaskManagerä¸­çš„çŠ¶æ€å­˜å‚¨ ğŸ”¥
    this.localStateStoresManager = taskExecutorServices.getTaskManagerStateStore();
    // è·å–TaskManagerä¸­çš„shuffleç¯å¢ƒ ğŸ”¥
    this.shuffleEnvironment = taskExecutorServices.getShuffleEnvironment();
    // è·å–TaskManagerä¸­çš„KVçŠ¶æ€å­˜å‚¨ ğŸ”¥
    this.kvStateService = taskExecutorServices.getKvStateService();
    this.ioExecutor = taskExecutorServices.getIOExecutor();
    // è·å–ResourceManagerLeaderæ£€ç´¢å™¨ ğŸ”¥
    this.resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever();

    this.hardwareDescription =
            HardwareDescription.extractFromSystem(taskExecutorServices.getManagedMemorySize());
    this.memoryConfiguration =
            TaskExecutorMemoryConfiguration.create(taskManagerConfiguration.getConfiguration());

    this.resourceManagerAddress = null;
    this.resourceManagerConnection = null;
    this.currentRegistrationTimeoutId = null;

    final ResourceID resourceId =
            taskExecutorServices.getUnresolvedTaskManagerLocation().getResourceID();
    this.jobManagerHeartbeatManager =
            createJobManagerHeartbeatManager(heartbeatServices, resourceId);
    this.resourceManagerHeartbeatManager =
            createResourceManagerHeartbeatManager(heartbeatServices, resourceId);

    ExecutorThreadFactory sampleThreadFactory =
            new ExecutorThreadFactory.Builder()
                    .setPoolName("flink-thread-info-sampler")
                    .build();
    ScheduledExecutorService sampleExecutor =
            Executors.newSingleThreadScheduledExecutor(sampleThreadFactory);
    this.threadInfoSampleService = new ThreadInfoSampleService(sampleExecutor);
}
```

ä¹‹åè°ƒç”¨`TaskExecutor`çš„æ„é€ æ–¹æ³•åˆ›å»ºä¸€ä¸ª`TaskExecutor`å¯¹è±¡ï¼Œ`TaskExecutor`æ˜¯è´Ÿè´£æ‰§è¡Œå¤šä¸ªä»»åŠ¡çš„ï¼Œé‚£ä¹ˆæ˜¯ä¸æ˜¯éå¸¸å¥½å¥‡å¯åŠ¨`TaskManager`æ—¶æ˜¯å­˜åœ¨slotçš„ï¼Œé‚£ä¹ˆslotç›¸å…³çš„ä»£ç æ˜¯åœ¨å“ªé‡Œå‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥é€šè¿‡`TaskExecutor`ç±»ä¸­ä»”ç»†çœ‹åˆ°æœ‰ä¸€ä¸ª`getSlotTable`çš„æ–¹æ³•ï¼Œä½†å®ƒæ˜¯é€šè¿‡`taskManagerServices`è¿›è¡Œè°ƒç”¨çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»§ç»­å‘ä¸Šçœ‹ï¼Œå¯ä»¥çœ‹åˆ°`TaskManagerServices`åœ¨`startTaskManager`æ–¹æ³•ä¸­å·²ç»è¢«åˆ›å»ºäº†ï¼Œé€šè¿‡ä¼ å…¥çš„å‚æ•°åˆ›å»ºäº†`TaskManagerServices`ï¼Œ`TaskManagerServices`æ˜¯`TaskExecutor`æœåŠ¡çš„å®¹å™¨ï¼ŒåŒ…æ‹¬`MemoryManager`ã€`IOManager`å’Œ`ShuffleEnvironment`ã€‚å…¶ä¸­çš„è¿™äº›æ‰€æœ‰çš„æœåŠ¡éƒ½æ˜¯å±äº`TaskExecutor`ï¼Œå› æ­¤ï¼Œç›¸åº”çš„`TaskManager`ä¹Ÿè´Ÿè´£å…³é—­å®ƒä»¬ã€‚åœ¨è¿™ä¸ª`TaskManagerServices`ç±»ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°slotå¯¹åº”çš„ä¸€äº›å®ç°ï¼Œå…·ä½“æˆ‘ä»¬å°±ä¸æ·±å…¥äº†ï¼Œæœ‰å…´è¶£çš„å¯ä»¥è‡ªå·±çœ‹çœ‹ã€‚

ä¸Šå›¾ä¸­æˆ‘æ ‡ğŸ”¥ çš„å¤§å®¶ç§ä¸‹æœ‰å…´è¶£éƒ½å¯ä»¥æ·±å…¥çœ‹çœ‹ï¼Œè¿™äº›éƒ½æ˜¯`TaskManagerServices`ä¸­ç®¡ç†çš„ä¸€äº›å’Œ`TaskExecutor`æœ‰å…³çš„æœåŠ¡ã€‚

##### 2. TaskManagerRunnerçš„startæ–¹æ³•

```java
// TaskManagerRunner
public void start() throws Exception {
    taskExecutorService.start();
}

public interface TaskExecutorService extends AutoCloseableAsync {
    void start();

    CompletableFuture<Void> getTerminationFuture();
}
```

`TaskManagerRunnerçš„start`æ–¹æ³•è°ƒç”¨äº†`taskExecutorService`çš„startæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°`taskExecutorService`çš„startæ–¹æ³•åº”è¯¥æ˜¯è°ƒç”¨äº†å­ç±»ï¼ˆ`TaskExecutorToServiceAdapter`ï¼‰çš„å…·ä½“å®ç°ï¼Œæˆ‘ä»¬æ·±å…¥ç»§ç»­çœ‹çœ‹ã€‚

```java
// TaskExecutorToServiceAdapter
public class TaskExecutorToServiceAdapter implements TaskManagerRunner.TaskExecutorService {

    private final TaskExecutor taskExecutor;

    private TaskExecutorToServiceAdapter(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }

    @Override
    public void start() {
        taskExecutor.start();
    }

    @Override
    public CompletableFuture<Void> getTerminationFuture() {
        return taskExecutor.getTerminationFuture();
    }

    @Override
    public CompletableFuture<Void> closeAsync() {
        return taskExecutor.closeAsync();
    }

    public static TaskExecutorToServiceAdapter createFor(TaskExecutor taskExecutor) {
        return new TaskExecutorToServiceAdapter(taskExecutor);
    }
}

// RpcEndpoint
/**
 * Triggers start of the rpc endpoint. This tells the underlying rpc server that the rpc
 * endpoint is ready to process remote procedure calls.
 */
public final void start() {
    rpcServer.start();
}
```

å¯ä»¥çœ‹åˆ°æœ€åè°ƒç”¨äº†çˆ¶ç±»`RpcEndpoint`çš„`start`æ–¹æ³•ï¼Œå¤§æ¦‚æ„æ€å°±æ˜¯å¯åŠ¨`RPC`çš„`EndPoint`ï¼Œå‘Šè¯‰åº•å±‚çš„RPCæœåŠ¡ï¼Œ`RPC EndPoint`å·²ç»å‡†å¤‡å¥½å¤„ç†è¿œç¨‹è¿‡ç¨‹çš„è°ƒç”¨äº†ã€‚

#### 5. æ€»ç»“

è¯¥ç¯‡æ–‡ç« å¤§æ¦‚åˆ†æäº†`TaskManager`çš„å…¥å£ç±»`TaskManagerRunner`çš„æºç ï¼Œåˆ†æäº†æ•´ä¸ªmainæ–¹æ³•çš„æ‰§è¡Œæµç¨‹ã€‚å…¶ä¸­æœ‰å¾ˆå¤šéƒ¨åˆ†å’Œ`JobManager`çš„å®ç°æœ‰äº›ç±»ä¼¼ï¼Œå½“ç„¶ä¹Ÿæœ‰å¾ˆå¤š`TaskManagerServices`ä¸­ç®¡ç†çš„æœåŠ¡æˆ‘ä»¬æ²¡æœ‰æ·±å…¥åˆ†æï¼Œæ„Ÿå…´è¶£çš„å°ä¼™ä¼´å¯ä»¥è‡ªå·±ä¸‹å»é’ˆå¯¹è¿™éƒ¨åˆ†çš„æºç åˆ†æä¸€æ³¢ã€‚ğŸ‘»

---

<div align=center>
    <font color='red' size=5>å…³æ³¨å¾®ä¿¡å…¬ä¼—å·ã€Šé›¶åŸºç¡€å­¦å¤§æ•°æ®ã€‹å›å¤ã€Flinkã€‘é¢†å–å…¨éƒ¨PDF</font>
</div>