### 《从0学习Flink源码》——Window

#### 1. 前言

Flink四大基石之一的Window，同时也是Flink中处理无限流的核心，我们可以针对不同的时间语义等采用不同的Window窗口进行计算。接下来我们看看在Flink中Window具体是怎么实现的？在Window中的数据又是何时触发计算的？

#### 2. Window的使用方法

##### 1. Keyed Windows

```
stream
       .keyBy(...)               <-  keyed versus non-keyed windows
       .window(...)              <-  required: "assigner"
      [.trigger(...)]            <-  optional: "trigger" (else default trigger)
      [.evictor(...)]            <-  optional: "evictor" (else no evictor)
      [.allowedLateness(...)]    <-  optional: "lateness" (else zero)
      [.sideOutputLateData(...)] <-  optional: "output tag" (else no side output for late data)
       .reduce/aggregate/apply()      <-  required: "function"
      [.getSideOutput(...)]      <-  optional: "output tag"
```

##### 2. Non-Keyed Windows

```
stream
       .windowAll(...)           <-  required: "assigner"
      [.trigger(...)]            <-  optional: "trigger" (else default trigger)
      [.evictor(...)]            <-  optional: "evictor" (else no evictor)
      [.allowedLateness(...)]    <-  optional: "lateness" (else zero)
      [.sideOutputLateData(...)] <-  optional: "output tag" (else no side output for late data)
       .reduce/aggregate/apply()      <-  required: "function"
      [.getSideOutput(...)]      <-  optional: "output tag"
```

我们重点关注Keyed Windows的具体实现，Non-Keyed Windows是基于Keyed Windows的一种特殊实现。

Window的基本用法：在window中需要一个WindowAssigner将KeyedStream转换成WindowedStream，然后就可以指定窗口的计算逻辑，这块分为全量窗口计算(apply和process)和增量窗口计算(reduce和aggregate)，之后就是触发窗口计算的Trigger以及能够修改窗口内元素的Evictor，此时便会通过WindowOperatorBuilder生成一个WindowOperator，窗口的处理逻辑主要就在WindowOperator中。