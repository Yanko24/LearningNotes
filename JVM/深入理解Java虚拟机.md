### 1. 走进Java

### 2. Java内存区域与内存溢出异常

### 3. 垃圾收集器与内存分配策略

#### 3.1 常见的几个概念

##### 3.1.1 Minor GC、Major GC、Mixed GC和Full GC

- 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
  - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集
  - 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC“这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集
  - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集

##### 3.1.2 吞吐量（Throughput）

处理器用于运行用户代码的时间与处理器总消耗时间的比值，即：
$$
吞吐量 = \frac{运行用户代码时间}{运行用户代码时间 + 运行垃圾收集时间}
$$
如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那么吞吐量就是100%。

##### 3.1.4 并行和并发

在讨论垃圾收集器的上下文语境中，并行和并发可以做如下理解：

- 并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。

- 并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

#### 3.2 对象已死？

##### 3.2.1 引用计数法（Reference Counting）

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器的值为零的对象就是不可能再被使用的。这种方式原理简单，判定效率也很高，但是无法解决对象之间的相互循环引用的问题。

```java
public class ReferenceCountingGC {
    public Object instance = null;

    private static final int _1MB = 1024 * 1024;

    /**
     * 改成员属性的唯一意义就是占用内存，以便在GC日志中看清楚是否有过回收
     */
    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }
}
```

即使将objA和objB都置为null，引用计数器的值也不是0，而是1，因为它们指向的对象又互相指向了对方，所以无法回收这两个对象。

##### 3.2.2 可达性分析算法（Reachability Analysis）

可达性分析算法是JVM默认使用的寻找垃圾算法，它通过一系列称为“GC Roots“的跟对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索所走过的路径称为”引用链”（Reference Chain），如果这个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能被再使用的。

<img src="images/可达性分析算法判定对象是否可回收.png" style="zoom:50%;" />

从上图中可以看出，对象object5、object6、object7之间虽然互有关联，但是它们到GC Roots是不可达的，因此它们会被判定为可回收的对象。

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中应用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError等），还有系统类加载器
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

##### 3.2.3 引用

在JDK1.2版本之前，一个对象只有“被引用”或“为被引用”这两种状态，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。譬如当内存空间还足够时，能保留在内存之中，如果内存孔吉娜在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象，对其进行回收。在JDK1.2版本之后，对引用的概念进行了扩充，分为以下四种：

- 强引用（Strongly Reference）：在程序代码中普遍存在的引用赋值，即类似“`Object obj = new Object()`“这种引用关系。无论何种情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
- 软引用（Soft Reference）：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。在JDK1.2版本之后提供了SoftReference类来实现软引用
- 弱引用（Weak Reference）：用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2版本之后提供饿了WeakReference类来实现弱引用
- 虚引用（Phantom Reference）：也被称之为“幽灵引用”或“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK1.2版本之后提供了PhantomReference类来实现虚引用

##### 3.2.4 生存还是死亡？

即便在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，还需要进行过两次标记一次筛选的过程。

<img src="images/两次标记一次筛选.png" style="zoom:50%;" />

如果对象被判定为有必要执行`finalize()`方法，那么该对象会被放置在一个`F-Queue`的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的`Finalizer`线程去执行它们的`finalize()`方法。这里所说的“执行”是指虚拟机会触发这个方法，但不会承诺一定会等待它运行结束。对象要想在`finalize()`方法中拯救自己，只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那么在第二次标记时它就会被移出”即将回收”的集合。如果此时这个对象还没有逃脱，那基本上它就要真的被回收了。同时需要注意的是，任何一个对象的`finalize()`方法都只会被系统自动调用一次，如果对象面临下一次回收，它的`finalize()`方法将不会被执行。

需要注意的是`finalize()`已经被官方明确声明为不推荐使用的语法，因为它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。`finalize()`能做的所有工作，使用`try-finally`或者其它方式都可以做得更好、更及时。

##### 3.2.5 回收方法区

《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上有未实现或未能完整实现方法去类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载），主要是方法区回收的成果低。

方法区的垃圾收集主要回收两部分内容：

- 废弃的常量：回收废弃常量与回收Java堆中的对象非常类型，当前系统没有引用、虚拟机中也没有其他地方引用
- 不再使用的类型，需同时满足以下3个条件
  - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例
  - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的
  - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

是否要对类型进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制，在Product版的虚拟机中还可以使用`-verbose:class`以及`-XX:+TraceClassLoading`，在FastDebug版的虚拟机中可以使用`-XX:+TraceClassUnLoading`。

#### 3.3 垃圾收集算法

从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾手收集“（Reference Counting GC）和“追踪式垃圾收集”（T racing GC）两大类，这两类也常被称为“直接垃圾收集”和“间接垃圾收集”。

##### 3.3.1 分代收集理论

当前商业虚拟机的垃圾收集器，大多都遵循了”分代收集“（Generational Collection）的理论进行设置，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以小王l

为了解决跨代引用的问题，对分代收集理论添加第三条经验法则：

- 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数

为了解决少量的跨代引用，只需在新生代上建立一个全部的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

##### 3.3.2 标记-清除算法

![](images/标记-清除算法.png)

标记-清除算法分为两阶段：首先标记出所有需要回收或存活的对象，标记完成后，统一回收掉所有被标记或未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。

- 执行效率不稳定：如果Java堆中包含大量对象且大部分需要回收，则导致标记和清除两个过程的执行效率都会随对象的数量增长而降低
- 内存空间的碎片化：标记-清除算法并不会对内存空间进行整理，所以标记、清除过后会导致内存空间碎片化严重，会导致以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存空间而不得不提前触发另一次垃圾收集动作

##### 3.3.3 标记-复制算法

![](images/标记-复制算法.png)

标记-复制算法常被简称为复制算法，将内存按容量划分为大小相等的两块，每次只使用其中一块。当进行垃圾收集时，只需要标记出那些存活的对象，然后将其移动到另一本空间，之后回收掉之前的那个区域的所有对象。

- 用于新生代的回收
- “Appel“式回收—把新生代的空间分为一块较大的Eden空间和两块较小的Survivor空间，HotSpot虚拟机默认Eden和Survivor的大小比例为8:1
- 当Survivor空间没有足够空间存放上一次新生代手机下来的存活对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）

##### 3.3.4 标记-整理算法

![](images/标记-整理算法.png)

标记-整理算法与标记-清除算法类似，其中标记过程都是对需要回收的对象进行标记，两者本质的差异在于标记-清除是一种非移动式的回收算法，而标记-整理是一种移动式的回收算法。标记-整理算法中的第二阶段整理是将所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

- 优点：空间连续
- 缺点：移动存活对象并更新所有引用是一种极为负重的操作，需要全程暂停用户应用程序才能进行，这种停顿被描述为“Stop The World“

#### 3.4 HotSpot的算法细节实现

##### 3.4.1 根节点枚举

所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World“的困扰。即便是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。

由于目前主流Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，在HotSpot的解决方案里，使用一组称为OopMap（Ordinary Object Pointer，OOP）的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。

##### 3.4.2 安全点

如果针对每个可能导致引用关系变化，或者说导致OopMap内容变化的指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。但实际上HotSpot并没有为每条指令都生成OopMap，只是在“特定位置”记录了这些信息，这些位置被称为安全点（Safepoint）。所以强制要求必须执行到安全点后才能够暂停用户程序，所以安全点的选定既不能太少以至于让收集器等待时间过长，也不能太频繁以至于过分增大运行时的内存负荷。

在垃圾收集发生时要让所有线程（这里不包括执行JNI调用的线程）都运行到最近的安全点，然后停顿下来。一般有两种方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）

- 抢先式中断：抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不再安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。（现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件）
- 主动式中断：主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标识位，各个线程执行过程中会不停地主动去轮询这个标志，一旦发现中断标志为真时就在自己最近的安全点上主动中断挂起。轮询标志的地方和安全点时重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象

##### 3.4.3 安全区域

安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行”的时候，也就是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。这种情况下，引入了一个安全区域（Safe Region）来解决，安全区域是指能够确保在某一段代码片段中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的，也可以把安全区域看作是被扩展拉伸了的安全点。

当用户线程执行到安全区域里面的代码时，就会标识自己已经进入了安全区域，这段时间内如果虚拟机发起垃圾收集时就不必管这些已经声明自己在安全区域的线程。当线程离开安全区域时，检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生，继续执行。否则就要一直等待，直到收到可以离开安全区域的信号为止。

##### 3.4.4 记忆集与卡表

在上面提到为了解决跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加载进GC Roots的扫描范围。时间上不只是新生代、老年代之间才有跨代引用，所有涉及部分区域收集（Partial GC）行为的垃圾收集器，都会面临相同的问题。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。不考虑效率和成本的话，可以用对象数据来实现，而在实际的垃圾收集场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，所以可以使用更为粗犷的记录粒度，常见的几种粒度如下：

- 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针
- 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针
- 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针

其实，第三种“卡精度”是目前最常用的一种记忆集的实现形式，采用的是一种称为“卡表”（Card Table）的数据结构。卡表和记忆集的关系就像是HashMap和Map的关系，卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。

在HotSpot中卡表的实现是一个字节数组，数组中每个元素对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，HotSpot中使用的卡页是2的9次幂，即512字节。一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应的卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则为0。在进行垃圾收集时，只要筛选出卡表中变脏的元素，就能轻易得出那些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描即可。

<img src="images/卡表与卡页对应示意图.png" style="zoom:60%;" />

##### 3.4.5 写屏障

##### 3.4.6 并发的可达性分析

#### 3.5 经典垃圾收集器

先用一张图，看看这7款经典的垃圾收集器，这7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。其中`Serial + CMS`和`ParNew + Serial Old`在JDK9中完全取消了对这些组合的支持。

<img src="images/7种经典的垃圾收集器.png" style="zoom:50%;" />

##### 3.5.1 Serial收集器

Serial收集器是一个单线程收集器，在进行垃圾收集时，必须暂停其他线程的工作，也就是发生“Stop The World”（STW）。在GC期间，应用是不可用的。

![](images/Serial+Serial-Old垃圾收集器.png)

- 标记-复制算法
- 最基础、最历史悠久的收集器
- 与其他收集器的单线程相比简单而高效，对于内存受限的环境，Serial收集器是额外内存消耗（Memory Footprint）最小的
- 单线程工作的收集器，效率会比极慢，消耗内存小
- 依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器

##### 3.5.2 ParNew收集器

ParNew收集器实质上是Serial收集器的多线程并行版本，在JDK7之前的系统中首选的新生代收集器，因为它是除了Serial收集器之外，可以与CMS收集器配合工作的收集器。

![](images/ParNew+Serial-Old垃圾收集器.png)

- 标记-复制算法
- ParNew收集器是激活CMS后（使用`-XX:+UseConcMarkSweepGC`选项）的默认新生代收集器，也可以使用`-XX:+/-UseParNewGC`选项来强制指定或者禁用它
- ParNew收集器默认开启的收集线程数与处理器核心数量相同，可以使用`-XX:ParallelGCThreads`来限制垃圾收集的线程数

##### 3.5.3 Parallel Scavenge收集器

Parallel Scavenge收集器重点关注的目标是达到一个可控制的吞吐量（Throughput），CMS等收集器关注的尽可能是缩短垃圾收集时用户线程的停顿时间，所以Parallel Scavenge收集器也叫做“吞吐量优先收集器”。

![](images/Parallel-Scavenge+Parallel-Old垃圾收集器.png)

- 标记-复制算法
- 能够并行收集的多线程收集器
- `-XX:MaxGCPauseMillis`控制最大垃圾收集停顿时间，允许的值是一个大于0的毫秒数，收集器尽力保证内存回收花费的时间不超过用户设定值，但注意，并不是越小越好
- `-XX:GCTimeRatio`控制吞吐量的大小，是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。如果此参数为19，则允许最大的垃圾收集时间就占总时间的5%（即1/(1+19)），默认为99
- `-XX:+UseAdptiveSizePolicy`内存自适应开关，开启后不需要人工置顶新生代大小（`-Xmn`）、Eden与Survivor区的比例（`-XX:SurvivorRatio`）以及晋升老年代对象大小（`-XX:PretenureSizeThreshold`）等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量

##### 3.5.4 Serial Old收集器

Serial Old是Serial收集器的老年代版本，也是一个单线程收集器。

![](images/Serial+Serial-Old垃圾收集器.png)

- 标记-整理算法
- 是Serial收集器的老年代版本，也是单线程收集器
- 主要提供客户端模式下的HotSpot虚拟机使用
- 服务端模式下的用途
  - 在JDK5以及之前的版本中与Parallel Scavenge收集器搭配使用
  - 作为CMS收集器发生失败时的后备预案，在并发收集发生“Concurrent Mode Failure“时使用

##### 3.5.5 Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，在JDK6开始提供。Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge和Parallel Old收集器的组合。需要注意的是Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并非直接调用Serial Old收集器，但是两个实现几乎是一样的。

![](images/Parallel-Scavenge+Parallel-Old垃圾收集器.png)

- 标记-整理算法
- Parallel Old是Parallel Scavenge收集器的老年代版本
- 支持多线程并发收集
- Parallel Scavenge + Parallel Old是JDK8默认的垃圾收集器

##### 3.5.6 CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，如果希望系统停顿时间尽可能短，以给用户带来最好的交互体检，则CMS收集器是非常合适的。CMS在一些公开文档中也被称之为“并发低停顿收集器“（Concurrent Low Pause Collector）。

![](images/Concurrent-Mark-Sweep垃圾收集器.png)

- 标记-清除算法
- CMS收集器运作过程
  - 初始标记（CMS initial mark）：标记一下GC Roots能直接关联到的对象，速度很快，在垃圾清理线程运行期间需要“Stop The World“
  - 并发标记（CMS concurrent mark）：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
  - 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分标记记录，这个阶段也需要“Stop The World“，比初始标记阶段时间稍长，但远比并发标记阶段的时间短
  - 并发清楚（CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的对象，可以和用户线程同时并发

- 以获取最短回收停顿时间为目标的收集器
- 缺点
  - 对处理器资源非常敏感，CMS收集器在并发阶段虽然不会导致用户线程停顿，但因为占用了一部分线程而导致应用程序变慢，降低吞吐量。CMS默认启动的回收线程数是`(处理器核心数量 + 3)/4`
  - 无法处理“浮动垃圾”（Floating Garbage），有可能出现“Concurrent Mode Failure“失败进而导致另一次完全“Stop The World“的Full GC的产生。因为垃圾收集阶段用户线程还在持续运行，所以必须要预留足够内存空间提供给用户线程使用，在JDK5的设置下，CMS收集器当老年代使用了68%的空间后就会被激活，在JDK6中，这个阈值已经提升到了92%，可以通过参数`-XX:CMSInitiatingOccupancyFraction`来调整该阈值。如果阈值设置太高，当CMS收集器运行期间，预留的内存不足以满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时虚拟机启动备用预案，冻结用户线程的执行，临时启用Serial Old收集器来进行老年代的垃圾收集
  - 在收集结束时会产生大量的空间碎片，当无法找到连续的空间分配给当前大对象使用时，不得不触发Full GC。为了解决此问题，引入了两个参数
    - `-XX:+UseCMSCompactAtFullCollection`：默认开启，从JDK9开始废弃。用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于内存整理必须移动活对象，是无法并发的，会导致停顿时间变长
    - `-XX:CMSFullGCsBeforeCompaction`：默认为0，这个参数的作用要求CMS收集器在执行若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC之前会先进行碎片整理

##### 3.5.7 Garbage First收集器

Garbage First（简称G1）开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准是那块内存存放的垃圾数量最多，回收收益最大，这也是G1独有的Mixed GC模式。

G1基于Region的内存布局是实现Mixed GC的关键，G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分成多大大小相等的独立区域（Region），每一个Region都可以根据需要扮演新生代的Eden空间、Survivor空间或者老年代空间，收集器能够对扮演不同角色的Region采用不同的策略去处理。Region有一部分特殊的Humongous区域，专门用来存储大对象。G1认为只要超过了一个Region容量一半的对象即为大对象，可以通过`-XX:G1HeapRegionSize`设置Region大小，范围是1MB~32MB，且应为2的N次幂。对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来看待。G1收集器的Region分区如下所示：

<img src="images/G1收集器Region分区.png" style="zoom:50%;" />

G1收集器把堆划分为大小相同的Region，每个Region都会扮演一个角色，分别是E、S、H、O。

- E代表Eden空间
- S代表Survivor空间
- H代表Humongous空间
- O代表Old空间

G1保留了新生代和老年代的概念，但是新生代和老年代不再是固定的，它们是一系列区域（不需要连续）的动态集合。G1收集器之所以能够建立可预测的停顿时间模型，是因为它将Region作为单次回收最小的单元，即每次收集到的空间都是Region大小的整数倍，这样可以避免在整个Java堆中进行全区域的垃圾收集。实现思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的停顿收集时间（参数`-XX:MaxGCPauseMillis`指定，默认为200毫秒），优先处理回收那些价值收益最大的Region列表。

![](images/G1垃圾收集器.png)

- 整理基于“标记-整理”算法，局部（两个Region之间）基于“标记-复制”算法
- G1收集器运作过程，除了并发标记外，其他阶段也要完全暂停用户线程
  - 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用的Region中分配对象。这个阶段需要停顿线程，但耗时很短，而且是借用Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿
  - 并发标记（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时很长，但可与用户线程并发执行。当对象图扫描完成后，还要重新处理SATB记录下的在并发时有引用变动的对象
  - 最终标记（Final Marking）：对用户线程做一个短暂的暂停，用于处理并发阶段后仍遗留下来的最后那少量的SATB记录
  - 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分的Region中的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及活对象的移动，必须暂停用户线程，由多条收集器线程并行完成
- 特点：
  - 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，可以通过并发的方式让用户程序继续运行，用并行的形式提高收集所需的时间，进一步缩短STW的时间
  - 分代收集：分代概念在G1中仍有保留，它能够采用不同的策略去处理扮演不同角色的Region，无论是新创建的对象还是已经存活一段时间、熬过多次收集的对象都能获取很好的收集效果
  - 空间整合：G1从整理上看基于“标记-整理”算法，从局部看基于“标记-复制”算法，G1运行期间不会产生内存空间碎片
  - 可预测停顿：G1比CMS厉害在能建立可预测的停顿时间模型，能让使用者明确在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不会超过N毫秒
  - 目前小内存应用CMS的表现大概率仍然要优于G1，这个优劣势的Java堆容量平衡点通常在6GB到8GB之间

#### 3.6 低延迟垃圾收集器

##### 3.6.1 Shenandoah收集器

##### 3.6.2 ZGC收集器

#### 3.7 选择合适的垃圾收集器

##### 3.7.1 Epsilon收集器

##### 3.7.2 收集器的权衡

##### 3.7.3 虚拟机及垃圾收集器日志

##### 3.7.4 垃圾收集器参数总结

#### 3.8 实战：内存分配与回收策略

##### 3.8.1 对象优先在Eden分配

##### 3.8.2 大对象直接进入老年代

##### 3.8.3 长期存活的对象将进入老年代

##### 3.8.4 动态对象年龄判定

##### 3.8.5 空间分配担保

### 4. 虚拟机性能监控、故障处理工具

#### 4.1 基础故障处理工具

#### 4.2 可视化故障处理工具

#### 4.3 HotSpot虚拟机插件及工具

### 5. 调优案例分析与实战

#### 5.1 案例分析